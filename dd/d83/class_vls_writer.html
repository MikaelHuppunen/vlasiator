<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vlasiator: VlsWriter Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Vlasiator<span id="projectnumber">&#160;25cfb9ae on dev (v4.0 + 5747 commits, including GPU_v1)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dd/d83/class_vls_writer.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">VlsWriter Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><h1>VLSV file format</h1>
<p>Vlasov simulation writes data into its own binary file format. The file format is quite flexible on datatypes. For example, in some files the data may be written in 4-byte floating point values, and 8-byte floating point values in another <a class="el" href="../../de/d31/_dispersion_8m.html#a1608ccff070b78b55b731b29c028673c">file(s)</a>. For this reason (and portability as well) each vlsv file contains the instructions on how to read the data.</p>
<p>It is expected that vlsv files can be efficiently written in parallel, for example by using MPI I/O.</p>
<h2>1. Endianness</h2>
<p>Endianness basically means the byte order of within longer data words, i.e. whether the most (big-endian) or least (little-endian) significant byte is written first. For example, floats and ints are typically 4-byte wide. There is no universal agreement on the order of the "sub-bytes". According to Wikipedia, </p><pre class="fragment">On some machines, while integers are represented in little-endian
form, floating point numbers are represented in big-endian form. 
</pre><p> Thus, a portable file format has to take care of endianness for integer and floating point datatypes separately.</p>
<p>Most modern computers (x86) use little-endian notation. As a side note, VisIt visualization tool natively reads VTK files which, in binary format, need to be written using big-endian notation.</p>
<p>The endianness of datatypes in a VLSV file is given in the header section. As a suggestion, these two fields should be the first two entries so that rest of the data can be read successfully. This behaviour is not required, however.</p>
<h2>2. Header</h2>
<p>The header portion consists of [{size}, {tag ID}, {value}] tuples. Each member of the tuple is an array, with number of elements and element byte sizes given in Table 1. </p><table class="doxtable">
<caption>Table 1. The structure of header entries.</caption>
<tr>
<th>Array Content</th><th>Array Size</th><th>Element Byte Size</th><th>Element Datatype</th></tr>
<tr>
<td>Size</td><td>1</td><td>1</td><td>unsigned integer</td></tr>
<tr>
<td>Header ID</td><td>1</td><td>1</td><td>unsigned integer</td></tr>
<tr>
<td>Value</td><td>Size</td><td>1</td><td>depends on Header ID</td></tr>
</table>
<p>The header should be read as follows: </p><ol>
<li>
Read one byte. This is the size fields. </li>
<li>
If size is zero, stop reading header. Otherwise continue to next step. </li>
<li>
Read one byte. This is the ID field. </li>
<li>
Read size bytes. This is the value field. </li>
<li>
Go back to step 1. </li>
</ol>
<p>It is thus possible to read the header of a VLSV file without understanding its contents. However, in order to read the rest of the file correctly, some values given in header have to be parsed correctly. The possible header tags are given in a Table 2.</p>
<table class="doxtable">
<caption>Table 2. List of header entries, and the datatypes of their value fields. </caption>
<tr>
<th>Tag Name</th><th>Value Datatype</th></tr>
<tr>
<td>BYTES_PER_CELL_CRD</td><td>unsigned integer</td></tr>
<tr>
<td>BYTES_PER_CELL_GID</td><td>unsigned integer</td></tr>
<tr>
<td>BYTES_PER_VARNAME_SIZE</td><td>unsigned integer</td></tr>
<tr>
<td>DIMENSIONS</td><td>unsigned integer</td></tr>
<tr>
<td>ENDIANNESS_FLOAT</td><td>unsigned integer</td></tr>
<tr>
<td>ENDIANNESS_INT</td><td>unsigned integer</td></tr>
<tr>
<td>VERSION</td><td>character array</td></tr>
</table>
<pre class="fragment">Morale: The {size} and {tag %ID} fields are one byte wide entries.
This guarantees that the header can be read correctly whether or not
the reader's endianness agrees with the endianness of datatypes in the
file. The header then contains instructions on how to read the rest of
the file.
</pre><h2>3. Static-Size Variable Description</h2>
<p>A "static-size variable" here means that for each cell, such variable has the same (byte) size, in oppose to a "dynamic-size
variables". A <em>bona fide</em> example of a static-size variable is the number density of particles, which for each cell is just a scalar value. An example of a dynamic-size variable is the velocity space grid stored in each cell. If the velocity space grid is adapted, it may have a different (byte) size for each spatial cell.</p>
<p>The description part consists of [{name size}, {name}, {varType}, {element size}] tuples. You can think that each member in the tuple is an array, with number of elements and element byte size given in Table 3.</p>
<p>Note that </p><ul>
<li>
Variable descriptions are in same order as they appear in the cell data (see Section 4). </li>
<li>
"Variable Type" contains one of the values defined in namespace VlsVariable. </li>
<li>
The data for each variable is an array. </li>
<li>
The number of elements in the data array can be deduced from the variable's type. </li>
<li>
Byte size of data array elements is given in "Data Slement Size" field. </li>
</ul>
<table class="doxtable">
<caption>Table 3. Contents of an entry containing a description of a static-size variable stored in a VLSV file. </caption>
<tr>
<th>Array Content</th><th>Array Size</th><th>Element Byte Size</th><th>Element Datatype</th></tr>
<tr>
<td>Name Size</td><td>1</td><td>BYTES_PER_VARNAME_SIZE</td><td>unsigned integer</td></tr>
<tr>
<td>Variable Name</td><td>Name Size</td><td>1</td><td>character</td></tr>
<tr>
<td>Variable Type</td><td>1</td><td>1</td><td>unsigned integer</td></tr>
<tr>
<td>Data Element Size</td><td>1</td><td>1</td><td>unsigned integer</td></tr>
</table>
<p>The variable descriptions should be read as follows: </p><ol>
<li>
Read BYTES_PER_VARNAME_SIZE bytes. This is the name size field. </li>
<li>
If name size has a zero value, stop reading descriptions. Otherwise continue to next step. </li>
<li>
Read name size bytes. This is the name field, which should be treated as a character array. </li>
<li>
Read one byte. This is the variable type field. </li>
<li>
Read one byte. This is the element size field. </li>
<li>
Go back to step 1. </li>
</ol>
<p>The variable descriptions are requested from <a class="el" href="../../db/da6/class_data_reducer.html">DataReducer</a>, via a call to DataReducer::getDescription, when a VLSV file is written. </p><pre class="fragment">Morale 1: Static-size variables are separated from dynamic-size
variables in order to reduce file size. Each dynamic-size variable
needs to be accompanied by its size for each cell. If the size field
was included for each static-size variable in each cell, the size of
cell data might increase by 25% in worst-case scenario. It is also, of
course, faster to read smaller files.

Morale 2: In the case of Vlasov simulations the user might want to get
the full six-dimensional distribution function for some cells. Writing
the distribution function for every cell results in HUGE output files
- 100 computation nodes having 16 GB memory each would already lead to
1.6 TB files!
</pre><p>After the variable descriptions have been read, the total byte size of static variable data per cell should be calculated, as the total size is needed when reading cell entries. Number of elements in a data array per variable type are given in Table 4.</p>
<p>Example: Variable description contained three entries: a SCALAR with element size 4, a VECTOR3 with element size 8, and a TENSOR33 with element size 4. Total size of static variable data per cell is thus 4</p><ul>
<li>4*8 + 9*4 = 72 bytes.</li>
</ul>
<table class="doxtable">
<caption>Table 4. Variable types defined in namespace VlsHeader, and the number of elements in the data arrays.</caption>
<tr>
<th>Variable Type</th><th>Number of Elements</th></tr>
<tr>
<td>NULLVARIABLE</td><td>0</td></tr>
<tr>
<td>SCALAR</td><td>1</td></tr>
<tr>
<td>VECTOR2</td><td>2</td></tr>
<tr>
<td>VECTOR3</td><td>3</td></tr>
<tr>
<td>TENSOR22</td><td>4</td></tr>
<tr>
<td>TENSOR23</td><td>6</td></tr>
<tr>
<td>TENSOR32</td><td>6</td></tr>
<tr>
<td>TENSOR33</td><td>9</td></tr>
</table>
<h2>4. Cell coordinates and static-size data</h2>
<p>This part of a VLSV file contains the physical coordinate values of each cell, as well as the static-size data. The contents of a cell entry depend on the dimensionality of the data, and on the definitions of static-size variables.</p>
<p>A cell entry consists of [{cell ID}, {cell crd}, {cell size}, {static data}] tuples. It is easiest to think of each element of the tuple as an array. The array sizes, byte sizes of each array element, and the element datatypes are given in Table 5.</p>
<p>Note that cell entries are in no particular order. This makes parallel writing of VLSV files convenient, as processes do not need to care about the order in which they write their local data to the file. The data per process can, however, be written one, few, or all cells at a time.</p>
<table class="doxtable">
<caption>Table 5. Description of the cell coordinate entry in VLSV file. Consider an entry to consist of four arrays with numbers of elements, and element byte sizes, given here. </caption>
<tr>
<th>Array Contents</th><th>Array Size</th><th>Element Byte Size</th><th>Element Datatype</th></tr>
<tr>
<td>Cell ID</td><td>1</td><td>BYTES_PER_CELL_GID</td><td>unsigned integer</td></tr>
<tr>
<td>Cell crd</td><td>DIMENSIONS</td><td>BYTES_PER_CELL_CRD</td><td>floating point</td></tr>
<tr>
<td>Cell size</td><td>DIMENSIONS</td><td>BYTES_PER_CELL_CRD</td><td>floating point</td></tr>
<tr>
<td>Static Data</td><td>See Section 3.</td><td>See Section 3.</td><td>floating point</td></tr>
</table>
<p>The cell data entries should be read as follows: </p><ol>
<li>
Read BYTES_PER_CELL_GID bytes, this gives the spatial cell global ID.. </li>
<li>
If each byte in ID has a value 255, i.e. all bits have unit value, stop reading. Otherwise continue to next step. </li>
<li>
Read 2*DIMENSIONS*BYTES_PER_CELL_CRD bytes. These are the x_min, y_min, z_min, dx, dy, dz values for the cell (in the case of three-dimensional data). </li>
<li>
Read static-size variable data. See Section 3 how to calculate the byte size. </li>
<li>
Go back to step 1. </li>
</ol>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>doc/<a class="el" href="../../dd/dd4/vlsv__format_8txt.html">vlsv_format.txt</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../dd/d83/class_vls_writer.html">VlsWriter</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for Vlasiator by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
